options
{
	static = true;
	DEBUG_PARSER = false;
	LOOKAHEAD = 4;
	FORCE_LA_CHECK = true;
}

PARSER_BEGIN(SimpleDBMSParser)
import com.sleepycat.je.Database;
import com.sleepycat.je.DatabaseException;
import com.sleepycat.je.DatabaseConfig;
import com.sleepycat.je.Cursor;
import com.sleepycat.je.*;
import com.sleepycat.je.Environment;
import com.sleepycat.je.EnvironmentConfig;
import com.sleepycat.je.DatabaseEntry;
import com.sleepycat.bind.serial.SerialBinding;
import com.sleepycat.bind.serial.*;
import com.sleepycat.bind.EntryBinding;
import com.sleepycat.je.LockMode;

import java.io.File;
import java.util.Vector;

public class SimpleDBMSParser
{
	public static final boolean suppressAlert = true;
	public static final boolean suppressWonder = true;
	public static final boolean suppressDebug = true;

	public static void debug(String input)
	{		if(!suppressDebug)
			System.out.println("[Debug]"+input);
	}

	public static void alert(String input)
	{
		if(!suppressAlert)
			System.out.println("[Alert]" + input);
	}

	public static void wonder(String input)
	{
		if(!suppressWonder)
			System.out.println("[Wonder]" + input);
	}

	public static Environment myDbEnvironment = null;
	public static Database myDatabase = null;

	public static QueryRequest request = null;
	public static AllTables alltables = null;
	public static Vector<Table > tables = null;


	public static EntryBinding<AllTables > allTablesBinding;
	public static EntryBinding<Table > tableBinding;
	public static StoredClassCatalog classCatalog;



	public static void main(String args[]) throws ParseException
	{
		SimpleDBMSParser parser = new SimpleDBMSParser(System.in);
		_connectDB();
		_setAllTablesFromDB();
		_setTablesFromDB();

		while (true)
		{
			try
			{
				System.out.print("DB_2013-11557> ");
				parser.command();
			}
			catch(ParseException e)
			{
				System.out.println(new SyntaxError());
				SimpleDBMSParser.ReInit(System.in);
			}
			catch (Exception e)
			{
				System.out.println("UNKNOWN ERROR : "+e.getMessage());
				SimpleDBMSParser.ReInit(System.in);
			}
			finally
			{
				request = null;
			}
		}
	}

	//connect DB
	public static void _connectDB()
	{
		EnvironmentConfig envConfig = new EnvironmentConfig();
		envConfig.setAllowCreate(true);
		myDbEnvironment = new Environment(new File("db/"), envConfig);

		DatabaseConfig dbConfig = new DatabaseConfig();
		dbConfig.setAllowCreate(true);
		myDatabase = myDbEnvironment.openDatabase(null, "sampleDatabase", dbConfig);
		classCatalog = new StoredClassCatalog(myDatabase);

		allTablesBinding = new SerialBinding(classCatalog,AllTables.class);
		tableBinding = new SerialBinding(classCatalog,Table.class);
	}

	//load metadata from DB
	public static void _setAllTablesFromDB()
	{
		Cursor cursor = null;
		DatabaseEntry key,data;
		cursor = myDatabase.openCursor(null,null);
		try
		{

			key = new DatabaseEntry("^alltable".getBytes("UTF-8"));
			data = new DatabaseEntry();

			if(cursor.getSearchKey(key,data,LockMode.DEFAULT)==OperationStatus.SUCCESS)
			{//the metadata exists.
				debug("Metadata exists already");
				alltables  = (AllTables)allTablesBinding.entryToObject(data);
			}
			else //the metatdata does not exist.
			{
				debug("Metadata created");
				alltables = new AllTables();
				allTablesBinding.objectToEntry(alltables,data);
			}
		}
		catch(Exception e)
		{
			alert("Error :_getAllTablesFromDB occured");
		}
		finally
		{
			if(cursor!=null)
				cursor.close();
		}
	}

	//load tables from DB
	public static void _setTablesFromDB()
	{
		tables = new Vector<Table >(0);
		for(String atablename : alltables.tableNames)
			tables.addElement(__getTableFromDB(atablename));
	}

	//must be used when the existence is 100% sure!!
	public static Table __getTableFromDB(String tableName)
	{
		Cursor cursor;
		DatabaseEntry key,data;
		cursor = myDatabase.openCursor(null,null);
		String keyString = "^alltable^"+tableName;
		Table theTable = null;
		try
		{
			key = new DatabaseEntry(keyString.getBytes("UTF-8"));
			data = new DatabaseEntry();

			cursor.getSearchKey(key,data,LockMode.DEFAULT);
			theTable = (Table)tableBinding.entryToObject(data);
		}
		catch(Exception e)
		{
			alert("Error : _getTable occured");
		}
		finally
		{
			if(cursor!=null)
				cursor.close();
		}
		return theTable;
	}

	//clear DB
	public static void __clearDB()
	{
		Cursor cursor = null;
		DatabaseEntry theKey=null,theData=null;
		try
		{
			cursor = myDatabase.openCursor(null,null);
			theKey = new DatabaseEntry();
			theData = new DatabaseEntry();

			//for all key-value pairs, delete it.
			int i=1;
			while(cursor.getNext(theKey,theData,LockMode.DEFAULT) == OperationStatus.SUCCESS)
			{				cursor.delete();
				debug("ClearDB : delete " + i++);				
			}
		}
		catch(Exception e)
		{
			alert("Error in __clearDB()");
		}
		finally
		{
			cursor.close();
		}
	}


	//save all tables to BDB
	public static void __saveTablesToDB()
	{
		for(Table atable : tables)
		{
			Cursor cursor = null;
			DatabaseEntry key,data;			
			String keyString = "^alltable^"+atable.tableName;
			try
			{
				cursor = myDatabase.openCursor(null,null);
				key = new DatabaseEntry(keyString.getBytes("UTF-8"));
				data = new DatabaseEntry();
				tableBinding.objectToEntry(atable,data);
				cursor.put(key,data);
			}
			catch(Exception e)
			{
				alert("Error : __saveTablesToDB() occured, tableName : "+atable.tableName+", error message : "+ e.getMessage());
			}
			finally
			{
				if(cursor!=null)
					cursor.close();
			}
		}
	}

	//save metadata to BDB
	public static void __saveAllTablesToDB()
	{
		Cursor cursor=null;
		DatabaseEntry key,data;
		cursor = myDatabase.openCursor(null,null);
		try
		{
			data = new DatabaseEntry();
		  	key = new DatabaseEntry("^alltable".getBytes("UTF-8"));
			allTablesBinding.objectToEntry(alltables,data);
			OperationStatus res = cursor.put(key,data);
		}
		catch(Exception e)
		{
			alert("Error : __saveAllTablesToDB() occured");
		}
		finally
		{
			if(cursor!=null)
				cursor.close();
		}
	}

	//disconnect BDB
	public static void _disconnectDB()
	{
		if(myDatabase != null)
			myDatabase.close();
		if(myDbEnvironment != null)
			myDbEnvironment.close();
	}

	//return Table searched from "tables" : __setTablesFromDB() must have been called in advance.
	public static Table _getTable(String tableName)
	{
		for(Table atable : tables)
			if(atable.tableName.equals(tableName))
				return atable;
		return null;
	}
}

PARSER_END(SimpleDBMSParser)

SKIP : { " " | "\r" | "\t" | "\n" }

TOKEN : /* Keywords */
{
	< EXIT : "exit" >
	| < INT : "int" >
	| < CHAR : "char" >
	| < DATE : "date" >
	| < CREATE : "create" >
	| < TABLE : "table" >
	| < NOT_NULL : "not null" >
	| < PRIMARY : "primary" >
	| < KEY : "key" >
	| < FOREIGN : "foreign" >
	| < REFERENCES : "references" >
	| < DROP : "drop" >
	| < DESC : "desc" >
	| < SELECT : "select" >
	| < AS : "as" >
	| < FROM : "from" >
	| < WHERE : "where" >
	| < AND : "and" >
	| < OR : "or" >
	| < NOT : "not" >
	| < IS : "is" >
	| < NULL : "null" >
	| < INTO : "into" >
	| < INSERT : "insert" >
	| < DELETE : "delete" >
	| < VALUES : "values" >
}



TOKEN :
{
	< SEMICOLON : ";" >
	| < PERIOD : "." >
	| < LEFT_PAREN : "(" >
	| < RIGHT_PAREN : ")" >
	| < COMMA : "," >
	| < QUOTE : "\'" >
	| < DOUBLE_QUOTE : "\"" >
	| < UNDERSCORE : "_" >
	| < SIGN : "+" | "-" >
	| < ASTERISK : "*" >
	| < INT_VALUE : (< SIGN >)? (< DIGIT >)+ >
	| < DIGIT : [ "0"-"9" ] >
	| < LEGAL_IDENTIFIER : < ALPHABET > (< ALPHABET > | < UNDERSCORE >)* >
	| < ALPHABET : [ "A"-"Z", "a"-"z" ] >

	| < DATE_VALUE : < NNNN >"-"< NN >"-"< NN >>
	| < NNNN : < DIGIT >< DIGIT >< DIGIT >< DIGIT >>
	| < NN : < DIGIT >< DIGIT >>
	| < COMP_OP : ">"|"<"|"="|">="|"<="|"!=" >
	| < CHAR_STRING : < QUOTE >(< NON_QUOTE_CHAR >)*< QUOTE >>
}

TOKEN :
{
		< NON_QUOTE_CHAR : < DIGIT >|< ALPHABET >|< NON_QUOTE_SPECIAL_CHAR >|" ">
		| < NON_QUOTE_SPECIAL_CHAR : ["!","@","#","$","%","^","&","*","(",")","[","]","{","}",":",";","?","/",",",".","<",">","\\","|","+","-","_","=","~","`"] >
}

	/*
	followings are implemented grammar.
	these are obvious unless otherwise commented.
	 */
	void command() :
	{}
	{
		queryList()
		| (
				< EXIT >
				< SEMICOLON >
				{
					//__clearDB();
					__saveTablesToDB();
					__saveAllTablesToDB();
					_disconnectDB();


					System.exit(0);
				}
				) 
	}

	void queryList() :
	{
		QueryMessage res;
	}
	{
		(
				res = query()
				< SEMICOLON >
				{
					System.out.print("DB_2013-11557> ");
					System.out.println(res);
				}
				)+
	}

	QueryMessage query() :
	{
		QueryMessage mes= new Dummy();
	}
	{
		(
				createTableQuery()
				{
					mes = request.execute(alltables,tables);
					request = null;

				}
				| dropTableQuery()
				{
					mes = request.execute(alltables,tables);
					request = null;
				}
				| descQuery()
				{
					mes = request.execute(alltables,tables);
					request = null;
				}
				| insertQuery()
				{
					mes = request.execute(alltables,tables);
					request = null;
				}
				| deleteQuery()
				{
					mes = request.execute(alltables,tables);
					request = null;
				}
				| selectQuery()
				{
					mes = request.execute(alltables,tables);
					request = null;
				}
		)
		(
				{
					return mes;
				}
		)  
	}

	void createTableQuery() :
	{
		String tName;
	}
	{
				< CREATE >
				< TABLE >
				{					request = new CreateTableRequest();
				}
				tName = tableName(){((CreateTableRequest)request).tableName = tName;}		
				tableElementList()
	}

	void tableElementList() :
	{}
	{
		< LEFT_PAREN >
		tableElement()
		(
				< COMMA >
				tableElement()
				)*
		< RIGHT_PAREN >
	}

	void tableElement() :
	{
	}
	{
		columnDefinition()
		| tableConstraintDefinition()
	}

	void columnDefinition() :
	{
		String colName;
		DataType datatype;
		boolean nullOk=true;
	}
	{
		colName = columnName()
				datatype = dataType()
				(
						< NOT_NULL >
						{
							nullOk=false;
						}
						)?
								{
			((CreateTableRequest)request).columnNames.addElement(colName);
			((CreateTableRequest)request).columns.addElement(new Column(colName,datatype,nullOk,false,false,((CreateTableRequest)request).tableName));
								}
	}

	void tableConstraintDefinition() :
	{}
	{
		primaryKeyConstraint()
		| referentialConstraint()
	}

	void primaryKeyConstraint() :
	{
		Vector<String > colList;
	}
	{
		< PRIMARY >
		< KEY >
		colList = columnNameList()
		{
			if(((CreateTableRequest)request).keyAlready)
			{
				((CreateTableRequest)request).dupKeyError=true;
				return;
			}
			else
			{
				((CreateTableRequest)request).keyAlready=true;
				((CreateTableRequest)request).primaryColumns = colList;
			}
		}
	}

	void referentialConstraint() :
	{
		Vector<String > refingC;
		String tName;
		Vector<String > refedC;
	}
	{
		(
				< FOREIGN >
				< KEY >
				refingC = columnNameList()
				< REFERENCES >
				tName = tableName()
				refedC = columnNameList()
				)
		(
				{((CreateTableRequest)request).referenceColumns.addElement(new RefColumn(refingC,tName,refedC));}
				)
	}

	Vector<String > columnNameList() :
	{
		Vector<String > result=new Vector<String >(0);
		String n;
	}
	{
		(
				< LEFT_PAREN >
				n=columnName(){result.addElement(n);}
				(
						< COMMA >
						n=columnName(){result.addElement(n);}
						)*
				< RIGHT_PAREN >
				)
		(
				{
					return result;
				}
				)
	}

	DataType dataType() :
	{
		Token n;
	}
	{
		< INT >
		{
			return new DataType(DataType.INT,0);
		}
		| (
				< CHAR >
				< LEFT_PAREN >
				n  = < INT_VALUE >
				< RIGHT_PAREN >
				{
					return new DataType(DataType.CHAR,Integer.parseInt(n.image));
				}
				)
		| < DATE > {return new DataType(DataType.DATE,0);}
	}

	String tableName() :
	{
		Token n;
	}
	{
		n = < LEGAL_IDENTIFIER >
		{
			return n.image.toLowerCase(); 
		}
	}

	String columnName() :
	{
		Token n;
	}
	{
		n = < LEGAL_IDENTIFIER >
		{
			return n.image.toLowerCase();
		}
	}
	/*
=======================DROP TABLE========================
=======================DROP TABLE========================
=======================DROP TABLE========================
	 */
	void dropTableQuery() :
	{}
	{
		< DROP >
		< TABLE >
		{			request = new DropTableRequest();
		}
		dropTableNameList()
	}

	void dropTableNameList() :
	{
		String tname;
	}
	{
		< ASTERISK >
		{
			((DropTableRequest)request).all = true;
		}
		|
		tname = tableName()	{((DropTableRequest)request).colList.addElement(tname);}
		(
				< COMMA >
				tname = tableName()	{((DropTableRequest)request).colList.addElement(tname);}
				)*
	}

	/*
=======================DESC========================
=======================DESC========================
=======================DESC========================
	 */
	void descQuery() :
	{
	}
	{
		< DESC >
		{			request = new DescRequest();
		}
		descTableNameList()
	}

	void descTableNameList() :
	{
		String tname;
	}
	{
		< ASTERISK >
		{
			((DescRequest)request).all = true;
		}
		|
		tname = tableName()	{((DescRequest)request).colList.addElement(tname);}
		(
				< COMMA >
				tname = tableName()	{((DescRequest)request).colList.addElement(tname);}
				)*
	}



//==========================================PROJECT3==========================================
//==========================================PROJECT3==========================================
//==========================================PROJECT3==========================================
//==========================================PROJECT3==========================================
//==========================================PROJECT3==========================================
//==========================================PROJECT3==========================================
//==========================================PROJECT3==========================================
//==========================================PROJECT3==========================================


//=======================INSERT,DELETE========================
//=======================INSERT,DELETE========================
//=======================INSERT,DELETE========================


void insertQuery() :
{
  String tabName;
}
{
  < INSERT >
  < INTO >
  {	request = new InsertRequest();
  }
  tabName = tableName()   {((InsertRequest)request).tableName = tabName;  }
  insertColumnsAndSource()
}

void insertColumnsAndSource() :
{
  Vector<String > columnNames = null;
  Vector<Value > values = null;
}
{
  (    
	  (
	    columnNames = columnNameList()
	  )?
	  values = valueList()
  )
  (
    {      
      ((InsertRequest)request).columnNames = columnNames;
      ((InsertRequest)request).values = values;
    }
  )
}

Vector<Value > valueList() :
{
  Vector<Value > result = new Vector<Value >(0);
  Value oneinput;
}
{
  (    
  < VALUES >
  < LEFT_PAREN >
  oneinput = value()  {result.addElement(oneinput); }
  (
    < COMMA >
    oneinput = value()  {result.addElement(oneinput); }
  )*
  < RIGHT_PAREN >
  )
  (
	{		return result;
	}
  )
}

Value value() :
{
  Value result = null;
  ComparableValue cv = null;
}
{
  (	    
	  < NULL >{result = new Value();}
	  | cv = comparableValue()
  )
  (
    {
      if(result==null)
      	return cv;
      else
      	return result;          }    
  )
}


//=======================DELETE========================
//=======================DELETE========================
//=======================DELETE========================

void deleteQuery() :
{
}
{
	(	    
	  < DELETE >
	  < FROM >  {request = new DeleteRequest(); System.out.println("FUCK");}
	  tableName()
	  (
	    whereClause()
	    {	        ((DeleteRequest)request).delAll=false;	    }
	  )?
	)
	(
	  {		
	  }
	)  
}




//=======================SELECT========================
//=======================SELECT========================
//=======================SELECT========================


void selectQuery() :
{
  Vector<SelectedColumn > selectedColumnList;
}
{
  (    
	  < SELECT >  {request = new SelectRequest();}
	  selectedColumnList = selectList()
	  tableExpression()
  )
  (
    {	  ((SelectRequest)request).selectedColumnList = selectedColumnList;
	  
    }
  )
}

Vector<SelectedColumn > selectList() :
{
  boolean selectAll = false;
  Vector<SelectedColumn > result = new Vector<SelectedColumn >(0);
  SelectedColumn temp;
}
{
  (  
	  < ASTERISK >  {selectAll = true;}
	  
	| temp = selectedColumn(){result.addElement(temp);}
	  (
	    < COMMA >
	    temp = selectedColumn(){result.addElement(temp);}
	  )*
  )
  (
    {		((SelectRequest)request).selectAll = selectAll;		return result;
    }
  )
}

/*
selected Column ::= (tableName.)?columnName(as columnName)?
both tableName and columnName are "legal identifier" although named differently.
parser cannot decide if the input identifier token is tableName or columnName.
parser need to lookahead one more token and decide.
Since lookahead(1) is default in javaCC, lookahead(2) is used.
*/

SelectedColumn selectedColumn() :
{
  String tablename="";
  String columnname;
  String aliasname="";
}
{
  (    
	  (
	    LOOKAHEAD(2)
	    tablename = tableName()
	    < PERIOD >
	  )?
	  columnname = columnName()
	  (
	    < AS >
	    aliasname = columnName()
	  )?
  )
  (
    {		return new SelectedColumn(columnname,tablename,aliasname);
    }
  )
}


void tableExpression() :
{
}
{
  fromClause()
  (
    whereClause()
  )?
}

void fromClause() :
{
  
}
{
  < FROM >
  tableReferenceList()
}

void tableReferenceList() :
{
  Vector<SelectedTable > tableList = new Vector<SelectedTable >(0);
  SelectedTable temp;
}
{
  (    
	  temp = referedTable(){tableList.addElement(temp);}   
	  (
	    < COMMA >
	    temp = referedTable(){tableList.addElement(temp);}
	  )*
  )
  (
    {
      ((SelectRequest)request).selectedTableList = tableList;            }
  )
}

SelectedTable referedTable() :
{
  String tablename;
  String aliasname="";
}
{
  (  
	  tablename=tableName()
	  (
	    < AS >
	    aliasname=tableName()
	  )?
  )
  (
    {		return new SelectedTable(tablename,aliasname);
    }
  )
}

void whereClause() :
{
  BooleanValueExpression bve;
}
{
  (    
	  < WHERE >
	  bve = booleanValueExpression()
  )
  (
    {
      ((SelectRequest)request).bve = bve;    }
  )
}

/*
following is original grammar stated.
void booleanValueExpression() :
{
}
{
  booleanTerm()
| booleanValueExpression()
  < OR >
  booleanTerm()
}

void booleanTerm() :
{
}
{
  booleanFactor()
| booleanTerm()
  < AND >
  booleanFactor()
}

both booleanValueExpression and booleanTerm have left recursion.
A::=Aa|a can be modified using extra nonterminal
1. A::= aA'
2. A'::= aA'|e

left recursion is removed from booleanValueExpression and booleanTerm using two _TEMP nonterminals
*/

BooleanValueExpression booleanValueExpression() :
{
  BooleanTerm bt;
  Vector<BooleanTerm > bts;
}
{
  (    
	  bt = booleanTerm()
	  bts = booleanValueExpression_TEMP()
  )
  (    {      bts.addElement(bt);
      return new BooleanValueExpression(bts);
    }
  )
}

Vector<BooleanTerm > booleanValueExpression_TEMP() :
{
  BooleanTerm bt=null;
  Vector<BooleanTerm > result=null;
}
{ 
  (    
	  (
	    < OR >
	    bt = booleanTerm()
	    result = booleanValueExpression_TEMP()
	  )?
  )
  (    {      if(result == null)
      	result = new Vector<BooleanTerm >(0);
      else
      	result.addElement(bt);
      return result;
    }
  )
}

BooleanTerm booleanTerm() :
{
  BooleanFactor bf;
  Vector<BooleanFactor > bfs;
}
{
  (
	  bf = booleanFactor()
	  bfs = booleanTerm_TEMP()
  )
  (    {      bfs.addElement(bf);
      return new BooleanTerm(bfs);
    }
  )
}

Vector<BooleanFactor > booleanTerm_TEMP() :
{
  BooleanFactor bf=null;
  Vector<BooleanFactor > result = null;  
}
{
  (    
	  (
	    < AND >
	    bf = booleanFactor()
	    result = booleanTerm_TEMP()
	  )?
  )
  (    {      if(result == null)
      	result = new Vector<BooleanFactor >(0);
      else
      	result.addElement(bf);
      return result;
    }
  )
}

BooleanFactor booleanFactor() :
{
  boolean isNot=false;
  BooleanTest test;
}
{
  (    
	  (
	    < NOT >{isNot = true;}
	  )?
	  test = booleanTest()
  )
  (    {      return new BooleanFactor(isNot,test);
    }
  )
}

BooleanTest booleanTest() :
{
  int type;
  Predicate pred=null;
  BooleanValueExpression bve=null;
}
{
  (
	  pred = predicate(){type = BooleanTest.PREDICATE;}
	| bve = parenthesizedBooleanExpression(){type = BooleanTest.EXPRESSION;}
  )
  (
    {
      return new BooleanTest(type,pred,bve);
    }      
  )
}

BooleanValueExpression parenthesizedBooleanExpression() :
{
  BooleanValueExpression result;
}
{
  (    
	  < LEFT_PAREN >
	  result = booleanValueExpression()
	  < RIGHT_PAREN >
  )
  (
    {
      return result;    }
  )
}
/*
predicate ::= nullPredicate | comparisonPredicate
nullPredicate ::= (tableName.)?columnName nullOperation
comparisonPredicate ::= comOperand comOp comOperand
comOperand ::= (tableName.)?columnName | comparableValue

thus, here is another ambiguity parser have to resolve.

predicate can be either nullPredicate or comparisonPredicate.
both have common prefix of (tableName.)?columnName
in order to decide between them, parser must know what comes after columnName. (If nullOperation, it is nullPredicate. If comOp, it is comparison-)
thus, parser needs 3 extra lookahead.
*/

Predicate predicate() :
{
  Predicate result=null;
}
{
  (    
	  LOOKAHEAD(4)
	  result = nullPredicate()
	| result = comparisonPredicate()
  )
(
  {
    return result;
  }
)
}

ComparisonPredicate comparisonPredicate() :
{
  CompareOperand lhs,rhs;
  CompareOperator op;
  Token n;
}
{
  (    
	  lhs = compOperand()
	  n = < COMP_OP >
	  rhs = compOperand()
  )
  (
    {		op = new CompareOperator(n.image);
		return new ComparisonPredicate(lhs,op,rhs);
    }
  )
}
/*
same type of ambiguity occurs.
need one extra lookahead as in "selectedColumn()"
*/
CompareOperand compOperand() :
{
  ComparableValue v=null;
  String tname="";
  String cname="";
  boolean isCV=false;
  boolean isTV=false;
}
{
  (    
	  v = comparableValue(){isCV = true;}
	| (
	    LOOKAHEAD(2)
	    tname = tableName(){isTV=true;}
	    < PERIOD >
	  )?
	  cname = columnName()
  )
  (
    {		return new CompareOperand(v,tname,cname,isTV,isCV);
    }
  )
}

ComparableValue comparableValue() :
{
  int type;
  Token n;
}
{
  (   
	  n = < INT_VALUE >{type = DataType.INT;}
	| n = < CHAR_STRING >{type = DataType.CHAR;}
	| n = < DATE_VALUE >{type = DataType.DATE;}
)
(
  {
    int length =0;
    if(type == DataType.CHAR)
    	length = n.image.length();	return new ComparableValue(n.image,type,length-2);
  }
)
}

/*
same type of ambiguity occurs.
need one extra lookahead as in "selectedColumn()"
*/
NullPredicate nullPredicate() :
{
  String tname="";
  String cname="";
  boolean istnameV=false;
  boolean isNot;
}
{
  (    
	  (
	    LOOKAHEAD(2)
	    tname = tableName() {istnameV = true;}
	    < PERIOD >
	  )?
	  cname = columnName()
	  isNot = nullOperation()
  )
  (
    {
      return new NullPredicate(tname,cname,istnameV,isNot);    }
  )
}

boolean nullOperation() :
{
  boolean isNot = false;
}
{
  (    
	  < IS >
	  (
	    < NULL >    {isNot = false;}
	  | < NOT_NULL >{isNot = true;}
	  )
  )
  (	{	  return isNot;
	}
  )
}


